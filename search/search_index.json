{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AutowareV2X Documentation # About AutowareV2X # AutowareV2X is an open-source module that can be added onto the newest Autoware.universe to enable V2X communication. It utilizes Vanetza as the protocol suite for ETSI C-ITS standards. We have also provided a working example of a CPM application, where Collective Perception Messages can be used to exchange perception information in Autoware. Getting started # Installation pages explain the installation steps of AutowareV2X and its prerequisites. Tutorials pages provide several tutorials to follow after installation. Design pages explain the design concept and architecture of AutowareV2X. Support pages are the place to go if you need additional help.","title":"Introduction"},{"location":"#autowarev2x-documentation","text":"","title":"AutowareV2X Documentation"},{"location":"#about-autowarev2x","text":"AutowareV2X is an open-source module that can be added onto the newest Autoware.universe to enable V2X communication. It utilizes Vanetza as the protocol suite for ETSI C-ITS standards. We have also provided a working example of a CPM application, where Collective Perception Messages can be used to exchange perception information in Autoware.","title":"About AutowareV2X"},{"location":"#getting-started","text":"Installation pages explain the installation steps of AutowareV2X and its prerequisites. Tutorials pages provide several tutorials to follow after installation. Design pages explain the design concept and architecture of AutowareV2X. Support pages are the place to go if you need additional help.","title":"Getting started"},{"location":"about/document-build/","text":"","title":"Document build"},{"location":"design/","text":"Design # Warning More to come A V2X communication software stack called Vanetza is integrated into the standalone autonomous driving software stack, Autoware . The V2X stack and the autonomous driving stack can be decoupled, allowing other applications to utilize the V2X router as well. A high-level overview of the architecture is shown below. Autoware is responsible for the perception task, while AutowareV2X manages the transmission and reception of messages over the V2X channel. Services that are necessary for the integration of Vanetza into Autoware were newly developed. The V2XApp is responsible for managing the various facilities such as DENM, CAM, CPM, while the V2XNode handles the conversion of information between the V2X messages and ROS2 messages. V2XNode # The V2XNode launches a ROS2 Node for AutowareV2X. Its main purpose is to act as the bridge interface between Autoware and AutowareV2X. Information that is to be utilized in V2X Applications are retreived from Autoware in the form of ROS2 topics. Similarily, information that is received by AutowareV2X through V2X communications is published as ROS2 topics in order to feed it back into Autoware. Input # Name Type Description /perception/object_recognition/objects autoware_auto_perception_msgs::msg::PredictedObjects Perceived Objects by Autoware /tf tf2_msgs::msg::TFMessage Pose of Ego Vehicle Output # Name Type Description /v2x/cpm/objects autoware_auto_perception_msgs::msg::PredictedObjects Objects received by CPMs Functions # Name Description objectsCallback(const autoware_auto_perception_msgs::msg::PredictedObjects::ConstSharedPtr msg) Call V2XApp::objectsCallback tfCallback Call V2XApp::tfCallback publishObjects(std::vector<CpmApplication::Object> *objectsStack, int cpm_num) publishCpmSenderObject Not used now V2XApp # CPM Facility #","title":"Design"},{"location":"design/#design","text":"Warning More to come A V2X communication software stack called Vanetza is integrated into the standalone autonomous driving software stack, Autoware . The V2X stack and the autonomous driving stack can be decoupled, allowing other applications to utilize the V2X router as well. A high-level overview of the architecture is shown below. Autoware is responsible for the perception task, while AutowareV2X manages the transmission and reception of messages over the V2X channel. Services that are necessary for the integration of Vanetza into Autoware were newly developed. The V2XApp is responsible for managing the various facilities such as DENM, CAM, CPM, while the V2XNode handles the conversion of information between the V2X messages and ROS2 messages.","title":"Design"},{"location":"design/#v2xnode","text":"The V2XNode launches a ROS2 Node for AutowareV2X. Its main purpose is to act as the bridge interface between Autoware and AutowareV2X. Information that is to be utilized in V2X Applications are retreived from Autoware in the form of ROS2 topics. Similarily, information that is received by AutowareV2X through V2X communications is published as ROS2 topics in order to feed it back into Autoware.","title":"V2XNode"},{"location":"design/#input","text":"Name Type Description /perception/object_recognition/objects autoware_auto_perception_msgs::msg::PredictedObjects Perceived Objects by Autoware /tf tf2_msgs::msg::TFMessage Pose of Ego Vehicle","title":"Input"},{"location":"design/#output","text":"Name Type Description /v2x/cpm/objects autoware_auto_perception_msgs::msg::PredictedObjects Objects received by CPMs","title":"Output"},{"location":"design/#functions","text":"Name Description objectsCallback(const autoware_auto_perception_msgs::msg::PredictedObjects::ConstSharedPtr msg) Call V2XApp::objectsCallback tfCallback Call V2XApp::tfCallback publishObjects(std::vector<CpmApplication::Object> *objectsStack, int cpm_num) publishCpmSenderObject Not used now","title":"Functions"},{"location":"design/#v2xapp","text":"","title":"V2XApp"},{"location":"design/#cpm-facility","text":"","title":"CPM Facility"},{"location":"design/architecture/","text":"","title":"Architecture"},{"location":"how-to-guides/","text":"How-to-guides # Warning Under Construction","title":"How-to-guides"},{"location":"how-to-guides/#how-to-guides","text":"Warning Under Construction","title":"How-to-guides"},{"location":"installation/","text":"Installing AutowareV2X # AutowareV2X is used as an add-on module to the open-source autonomous driving stack called Autoware . Therefore, in order to properly use AutowareV2X, Autoware must first be installed on the system. You can install AutowareV2X directly onto a PC through the Source Installation or use it as a Docker container through the Docker Installation . Note In order to proceed with the Tutorials , you will need to continue with the Docker Installatioon .","title":"Installing AutowareV2X"},{"location":"installation/#installing-autowarev2x","text":"AutowareV2X is used as an add-on module to the open-source autonomous driving stack called Autoware . Therefore, in order to properly use AutowareV2X, Autoware must first be installed on the system. You can install AutowareV2X directly onto a PC through the Source Installation or use it as a Docker container through the Docker Installation . Note In order to proceed with the Tutorials , you will need to continue with the Docker Installatioon .","title":"Installing AutowareV2X"},{"location":"installation/docker-installation/","text":"Docker Installation # In order to run the simulations explained in the Tutorials section, you will need to proceed with the Docker installation. Note Also refer to Autoware's Docker Installation for the Docker-based installation of Autoware.universe. Installing Autoware (Docker version) # For the newest documentation for the Docker installation of Autoware, see their official documentation . Setup # mkdir -p ~/workspace && cd ~/workspace git clone https://github.com/autowarefoundation/autoware.git autoware_docker cd autoware_docker # Install dependencies using Ansible ./setup-dev-env.sh docker # Make directory to store maps mkdir -p ~/data/maps Launch container # # Launch Autoware container (with NVIDIA GPU) rocker --nvidia --x11 --user --privileged --volume $HOME/workspace/autoware_docker --volume $HOME/data -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda # Launch Autoware container (without NVIDIA GPU) rocker -e LIBGL_ALWAYS_SOFTWARE=1 --x11 --user --privileged --volume $HOME/workspace/autoware_docker --volume $HOME/data -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda Adding AutowareV2X # Note From here, run commands inside the container. Move into autoware_docker directory. cd ~/workspace/autoware_docker Edit the autoware.repos file and add the following two repositories to the end. v2x/autowarev2x: type: git url: git@github.com:tlab-wide/AutowareV2X.git version: main v2x/vanetza: type: git url: git@github.com:tlab-wide/vanetza.git version: socktap-cpm-tr103562 Update the repository mkdir src vcs import src < autoware.repos vcs pull src Install dependent ROS packages sudo apt update rosdep update rosdep install --from-paths . --ignore-src --rosdistro $ROS_DISTRO -r Build the workspace colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release","title":"Docker Installation"},{"location":"installation/docker-installation/#docker-installation","text":"In order to run the simulations explained in the Tutorials section, you will need to proceed with the Docker installation. Note Also refer to Autoware's Docker Installation for the Docker-based installation of Autoware.universe.","title":"Docker Installation"},{"location":"installation/docker-installation/#installing-autoware-docker-version","text":"For the newest documentation for the Docker installation of Autoware, see their official documentation .","title":"Installing Autoware (Docker version)"},{"location":"installation/docker-installation/#setup","text":"mkdir -p ~/workspace && cd ~/workspace git clone https://github.com/autowarefoundation/autoware.git autoware_docker cd autoware_docker # Install dependencies using Ansible ./setup-dev-env.sh docker # Make directory to store maps mkdir -p ~/data/maps","title":"Setup"},{"location":"installation/docker-installation/#launch-container","text":"# Launch Autoware container (with NVIDIA GPU) rocker --nvidia --x11 --user --privileged --volume $HOME/workspace/autoware_docker --volume $HOME/data -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda # Launch Autoware container (without NVIDIA GPU) rocker -e LIBGL_ALWAYS_SOFTWARE=1 --x11 --user --privileged --volume $HOME/workspace/autoware_docker --volume $HOME/data -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda","title":"Launch container"},{"location":"installation/docker-installation/#adding-autowarev2x","text":"Note From here, run commands inside the container. Move into autoware_docker directory. cd ~/workspace/autoware_docker Edit the autoware.repos file and add the following two repositories to the end. v2x/autowarev2x: type: git url: git@github.com:tlab-wide/AutowareV2X.git version: main v2x/vanetza: type: git url: git@github.com:tlab-wide/vanetza.git version: socktap-cpm-tr103562 Update the repository mkdir src vcs import src < autoware.repos vcs pull src Install dependent ROS packages sudo apt update rosdep update rosdep install --from-paths . --ignore-src --rosdistro $ROS_DISTRO -r Build the workspace colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release","title":"Adding AutowareV2X"},{"location":"installation/source-installation/","text":"Source Installation # Prerequisites # OS Ubuntu 20.04 Ubuntu 22.04 ROS ROS2 Galactic Installing Autoware # Refer to the Official Autoware Documentation for the newest installation procedures. In a nutshell, you can run the following commands: # Clone repository git clone https://github.com/autowarefoundation/autoware.git cd autoware # Install dependencies using Ansible ./setup-dev-env.sh # Use vcstool to import more repositories mkdir src vcs import src < autoware.repos # Install dependent ROS packages source /opt/ros/galactic/setup.bash rosdep update rosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO # Build the workspace colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE = Release Adding AutowareV2X # Edit the autoware.repos file and add the following two repositories to the end. v2x/autoware_v2x: type: git url: git@github.com:tlab-wide/autoware_v2x.git version: main v2x/vanetza: type: git url: git@github.com:tlab-wide/vanetza.git version: socktap-cpm-tr103562 Update the repository vcs import src < autoware.repos vcs pull src Install dependent ROS packages source /opt/ros/galactic/setup.bash rosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO Build the workspace colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release","title":"Source Installation"},{"location":"installation/source-installation/#source-installation","text":"","title":"Source Installation"},{"location":"installation/source-installation/#prerequisites","text":"OS Ubuntu 20.04 Ubuntu 22.04 ROS ROS2 Galactic","title":"Prerequisites"},{"location":"installation/source-installation/#installing-autoware","text":"Refer to the Official Autoware Documentation for the newest installation procedures. In a nutshell, you can run the following commands: # Clone repository git clone https://github.com/autowarefoundation/autoware.git cd autoware # Install dependencies using Ansible ./setup-dev-env.sh # Use vcstool to import more repositories mkdir src vcs import src < autoware.repos # Install dependent ROS packages source /opt/ros/galactic/setup.bash rosdep update rosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO # Build the workspace colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE = Release","title":"Installing Autoware"},{"location":"installation/source-installation/#adding-autowarev2x","text":"Edit the autoware.repos file and add the following two repositories to the end. v2x/autoware_v2x: type: git url: git@github.com:tlab-wide/autoware_v2x.git version: main v2x/vanetza: type: git url: git@github.com:tlab-wide/vanetza.git version: socktap-cpm-tr103562 Update the repository vcs import src < autoware.repos vcs pull src Install dependent ROS packages source /opt/ros/galactic/setup.bash rosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO Build the workspace colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release","title":"Adding AutowareV2X"},{"location":"support/","text":"Support # Contact: yuasabe[at]hongo.wide.ad.jp","title":"Support"},{"location":"support/#support","text":"Contact: yuasabe[at]hongo.wide.ad.jp","title":"Support"},{"location":"support/docs-guide/","text":"How to generate Documentation # mkdocs # Run development server. mkdocs serve Deploy to gh-pages. mkdocs gh-deploy Doxygen # doxygen Doxyfile","title":"How to generate Documentation"},{"location":"support/docs-guide/#how-to-generate-documentation","text":"","title":"How to generate Documentation"},{"location":"support/docs-guide/#mkdocs","text":"Run development server. mkdocs serve Deploy to gh-pages. mkdocs gh-deploy","title":"mkdocs"},{"location":"support/docs-guide/#doxygen","text":"doxygen Doxyfile","title":"Doxygen"},{"location":"tutorials/","text":"Tutorials # AutowareV2X can be first verified using Autoware's Planning Simulator . Running Autoware in the Planning Simulator Then, after you are familiar with how AutowareV2X works, you can use actual devices to test AutowareV2X. Running AutowareV2X on Actual Devices","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"AutowareV2X can be first verified using Autoware's Planning Simulator . Running Autoware in the Planning Simulator Then, after you are familiar with how AutowareV2X works, you can use actual devices to test AutowareV2X. Running AutowareV2X on Actual Devices","title":"Tutorials"},{"location":"tutorials/actual-devices/","text":"Running AutowareV2X on Actual Devices # Warning Under Construction","title":"Running AutowareV2X on Actual Devices"},{"location":"tutorials/actual-devices/#running-autowarev2x-on-actual-devices","text":"Warning Under Construction","title":"Running AutowareV2X on Actual Devices"},{"location":"tutorials/planning-simulation/","text":"Running AutowareV2X in the Planning Simulator # Simulations can be an easy way of verifying the functionality of AutowareV2X before an actual field test. AutowareV2X can be run in a simulation environment using Autoware's Planning Simulator . An ITS-S is composed of Autoware as the autonomous driving stack and AutowareV2X as its V2X communication stack. Each ITS-S is executed inside a Docker container, and the wireless communication medium between ITS-Ss are modeled with Docker networks. A dynamic ITS-S is defined as a CAV, while a static ITS-S is considered a RSU. Perceived Objects are sent out on the network as CPMs. Note Make sure you have completed Autoware's Planning Simulator Tutorial before continuing. In order to test both the sender and receiver functionalities, we will need at least two ITS-S instances. The Docker environment to create # We will be creating the Docker environment as depicted in the figure below. There will be two Docker containers to represent the two ITS-Ss, each of which includes Autoware.universe and AutowareV2X. They will both be a part of the Docker network called v2x_net with the subnet 10.0.0.0/24 . \"Autoware Container #1\" and \"Autoware Container #2\" will be described as autoware_1 and autoware_2 respectively. Create a Docker network for V2X communication # docker network create --driver = bridge --subnet = 10 .0.0.0/24 v2x_net -o com.docker.network.bridge.name = \"v2x_net\" Launch two ITS-S containers # In one terminal, use rocker to launch container autoware_1 : rocker --nvidia --x11 --user --privileged --volume $HOME /workspace/autoware_docker --volume $HOME /data --network = v2x_net --name autoware_1 --oyr-run-arg \"--ip 10.0.0.2 --hostname autoware_1\" -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda In another terminal, use rocker to launch container autoware_2 : rocker --nvidia --x11 --user --privileged --volume $HOME/workspace/autoware_docker --volume $HOME/data --network=v2x_net --name autoware_2 --oyr-run-arg \"--ip 10.0.0.3 --hostname autoware_2\" -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda Run Planning Simulator # Run the Planning Simulator in both autoware_1 and autoware_2 . In autoware_1 : cd ~/workspace/autoware_docker source ~/autoware_docker/install/setup.bash export AWID=1 # autoware_1 source ~/workspace/autoware_docker/src/v2x/autowarev2x/setup.sh ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/data/maps/sample-map-planning vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit Also, in autoware_1 , set the ego-vehicle position by clicking 2D Pose Estimate . Try adding some dummy cars by clicking 2D Dummy Car . Note that you can make the dummy cars to be static by changing its Velocity to 0 in the Tool Properties pane. In autoware_2 : cd ~/workspace/autoware_docker source ~/autoware_docker/install/setup.bash export AWID=2 # autoware_2 source ~/workspace/autoware_docker/src/v2x/autowarev2x/setup.sh ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/data/maps/sample-map-planning vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit Run AutowareV2X # In another terminal, connect to the autoware_1 and autoware_2 containers, and start AutowareV2X in both of them. We will set autoware_1 to be the CPM sender, and autoware_2 to be the CPM receiver. In autoware_1 : docker exec -it autoware_1 bash sudo su cd ~/workspace/autoware_docker source ~/workspace/autoware_docker/install/setup.bash export AWID=1 source ./src/v2x/autowarev2x/setup.sh ros2 launch autoware_v2x v2x.launch.xml network_interface:=eth0 You should see the command output like below. It shows that you are \"Sending CPM with n objects\", and the [objectsList] line describes the following information: cpm_num, objectID, object.uuid, object.to_send, object.to_send_trigger . In autoware_2 : docker exec -it autoware_2 bash sudo su cd ~/workspace/autoware_docker source ~/workspace/autoware_docker/install/setup.bash export AWID=2 source ./src/v2x/autowarev2x/setup.sh ros2 launch autoware_v2x v2x.launch.xml network_interface:=eth0 is_sender:=false When both the sender and receiver is launched, you should see that the receiver ( autoware_2 ) will start receiving CPMs like below. Show CPM-shared objects in RViz # Press \"Add\" from the Displays Panel Choose \"By topic\", then select PredictedObjects from /v2x/cpm/objects The CPM-shared objects are shown in Rviz! Run scenarios # In order to run scenarios, the scenario_simulator_v2 must be installed: Launch new Autoware container rocker --nvidia --x11 --user --volume $HOME/workspace/autoware_docker --volume $HOME/data -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda Add simulator.repos cd workspace/autoware_docker vcs import src < simulator.repos Install dependent ROS packages sudo apt update rosdep update rosdep install --from-paths src --ignore-src --rosdistro $ROS_DISTRO -r Rebuild workspace colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release Download scenario. gdown -O ~/data/scenarios/ 'https://drive.google.com/uc?id=1FXwSSWeFDTMz7qsG-J7pyJA6RgjksqCy' Launch scenario_test_runner and specify scenario. ros2 launch scenario_test_runner scenario_test_runner.launch.py map_path:=$HOME/data/maps/sample-map-planning sensor_model:=sample_sensor_kit vehicle_model:=sample_vehicle scenario:=$HOME/data/scenarios/busy_kashiwa_scenario.yaml launch_autoware:=true","title":"Running AutowareV2X in the Planning Simulator"},{"location":"tutorials/planning-simulation/#running-autowarev2x-in-the-planning-simulator","text":"Simulations can be an easy way of verifying the functionality of AutowareV2X before an actual field test. AutowareV2X can be run in a simulation environment using Autoware's Planning Simulator . An ITS-S is composed of Autoware as the autonomous driving stack and AutowareV2X as its V2X communication stack. Each ITS-S is executed inside a Docker container, and the wireless communication medium between ITS-Ss are modeled with Docker networks. A dynamic ITS-S is defined as a CAV, while a static ITS-S is considered a RSU. Perceived Objects are sent out on the network as CPMs. Note Make sure you have completed Autoware's Planning Simulator Tutorial before continuing. In order to test both the sender and receiver functionalities, we will need at least two ITS-S instances.","title":"Running AutowareV2X in the Planning Simulator"},{"location":"tutorials/planning-simulation/#the-docker-environment-to-create","text":"We will be creating the Docker environment as depicted in the figure below. There will be two Docker containers to represent the two ITS-Ss, each of which includes Autoware.universe and AutowareV2X. They will both be a part of the Docker network called v2x_net with the subnet 10.0.0.0/24 . \"Autoware Container #1\" and \"Autoware Container #2\" will be described as autoware_1 and autoware_2 respectively.","title":"The Docker environment to create"},{"location":"tutorials/planning-simulation/#create-a-docker-network-for-v2x-communication","text":"docker network create --driver = bridge --subnet = 10 .0.0.0/24 v2x_net -o com.docker.network.bridge.name = \"v2x_net\"","title":"Create a Docker network for V2X communication"},{"location":"tutorials/planning-simulation/#launch-two-its-s-containers","text":"In one terminal, use rocker to launch container autoware_1 : rocker --nvidia --x11 --user --privileged --volume $HOME /workspace/autoware_docker --volume $HOME /data --network = v2x_net --name autoware_1 --oyr-run-arg \"--ip 10.0.0.2 --hostname autoware_1\" -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda In another terminal, use rocker to launch container autoware_2 : rocker --nvidia --x11 --user --privileged --volume $HOME/workspace/autoware_docker --volume $HOME/data --network=v2x_net --name autoware_2 --oyr-run-arg \"--ip 10.0.0.3 --hostname autoware_2\" -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda","title":"Launch two ITS-S containers"},{"location":"tutorials/planning-simulation/#run-planning-simulator","text":"Run the Planning Simulator in both autoware_1 and autoware_2 . In autoware_1 : cd ~/workspace/autoware_docker source ~/autoware_docker/install/setup.bash export AWID=1 # autoware_1 source ~/workspace/autoware_docker/src/v2x/autowarev2x/setup.sh ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/data/maps/sample-map-planning vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit Also, in autoware_1 , set the ego-vehicle position by clicking 2D Pose Estimate . Try adding some dummy cars by clicking 2D Dummy Car . Note that you can make the dummy cars to be static by changing its Velocity to 0 in the Tool Properties pane. In autoware_2 : cd ~/workspace/autoware_docker source ~/autoware_docker/install/setup.bash export AWID=2 # autoware_2 source ~/workspace/autoware_docker/src/v2x/autowarev2x/setup.sh ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/data/maps/sample-map-planning vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit","title":"Run Planning Simulator"},{"location":"tutorials/planning-simulation/#run-autowarev2x","text":"In another terminal, connect to the autoware_1 and autoware_2 containers, and start AutowareV2X in both of them. We will set autoware_1 to be the CPM sender, and autoware_2 to be the CPM receiver. In autoware_1 : docker exec -it autoware_1 bash sudo su cd ~/workspace/autoware_docker source ~/workspace/autoware_docker/install/setup.bash export AWID=1 source ./src/v2x/autowarev2x/setup.sh ros2 launch autoware_v2x v2x.launch.xml network_interface:=eth0 You should see the command output like below. It shows that you are \"Sending CPM with n objects\", and the [objectsList] line describes the following information: cpm_num, objectID, object.uuid, object.to_send, object.to_send_trigger . In autoware_2 : docker exec -it autoware_2 bash sudo su cd ~/workspace/autoware_docker source ~/workspace/autoware_docker/install/setup.bash export AWID=2 source ./src/v2x/autowarev2x/setup.sh ros2 launch autoware_v2x v2x.launch.xml network_interface:=eth0 is_sender:=false When both the sender and receiver is launched, you should see that the receiver ( autoware_2 ) will start receiving CPMs like below.","title":"Run AutowareV2X"},{"location":"tutorials/planning-simulation/#show-cpm-shared-objects-in-rviz","text":"Press \"Add\" from the Displays Panel Choose \"By topic\", then select PredictedObjects from /v2x/cpm/objects The CPM-shared objects are shown in Rviz!","title":"Show CPM-shared objects in RViz"},{"location":"tutorials/planning-simulation/#run-scenarios","text":"In order to run scenarios, the scenario_simulator_v2 must be installed: Launch new Autoware container rocker --nvidia --x11 --user --volume $HOME/workspace/autoware_docker --volume $HOME/data -- ghcr.io/autowarefoundation/autoware-universe:latest-cuda Add simulator.repos cd workspace/autoware_docker vcs import src < simulator.repos Install dependent ROS packages sudo apt update rosdep update rosdep install --from-paths src --ignore-src --rosdistro $ROS_DISTRO -r Rebuild workspace colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release Download scenario. gdown -O ~/data/scenarios/ 'https://drive.google.com/uc?id=1FXwSSWeFDTMz7qsG-J7pyJA6RgjksqCy' Launch scenario_test_runner and specify scenario. ros2 launch scenario_test_runner scenario_test_runner.launch.py map_path:=$HOME/data/maps/sample-map-planning sensor_model:=sample_sensor_kit vehicle_model:=sample_vehicle scenario:=$HOME/data/scenarios/busy_kashiwa_scenario.yaml launch_autoware:=true","title":"Run scenarios"},{"location":"tutorials/planning-simulation/network-emulation/","text":"Network Emulation # The tc command can be used within the Docker container to emulate various network parameters. In autoware_1 for example, use tc to add a delay of 100ms. sudo tc qdisc add dev eth0 root netem delay 100ms To remove delay, simply: sudo tc qdisc delete dev eth0 root netem delay 100ms To show all qdisc: sudo tc qdisc show Documentation about tc-netem .","title":"Network Emulation"},{"location":"tutorials/planning-simulation/network-emulation/#network-emulation","text":"The tc command can be used within the Docker container to emulate various network parameters. In autoware_1 for example, use tc to add a delay of 100ms. sudo tc qdisc add dev eth0 root netem delay 100ms To remove delay, simply: sudo tc qdisc delete dev eth0 root netem delay 100ms To show all qdisc: sudo tc qdisc show Documentation about tc-netem .","title":"Network Emulation"},{"location":"tutorials/planning-simulation/rosbag-and-analysis/","text":"Recording Rosbag and Tcpdump for Analysis # Record both rosbag and tcpdump # In autoware_1 : cd ~/workspace/autoware_docker ros2 bag record -o test_sender_rosbag /perception/object_recognition/objects /tf tcpdump -i eth0 -w test_sender_tcpdump In autoware_2 : cd ~/workspace/autoware_docker ros2 bag record -o test_receiver_rosbag /v2x/cpm/objects /tf tcpdump -i eth0 -w test_receiver_tcpdump Analyze in JupyteLab # Plot the x,y coordinates of objects in test_sender_rosbag # Export the necessary topics of the Rosbag to a CSV file","title":"Recording Rosbag and Tcpdump for Analysis"},{"location":"tutorials/planning-simulation/rosbag-and-analysis/#recording-rosbag-and-tcpdump-for-analysis","text":"","title":"Recording Rosbag and Tcpdump for Analysis"},{"location":"tutorials/planning-simulation/rosbag-and-analysis/#record-both-rosbag-and-tcpdump","text":"In autoware_1 : cd ~/workspace/autoware_docker ros2 bag record -o test_sender_rosbag /perception/object_recognition/objects /tf tcpdump -i eth0 -w test_sender_tcpdump In autoware_2 : cd ~/workspace/autoware_docker ros2 bag record -o test_receiver_rosbag /v2x/cpm/objects /tf tcpdump -i eth0 -w test_receiver_tcpdump","title":"Record both rosbag and tcpdump"},{"location":"tutorials/planning-simulation/rosbag-and-analysis/#analyze-in-jupytelab","text":"","title":"Analyze in JupyteLab"},{"location":"tutorials/planning-simulation/rosbag-and-analysis/#plot-the-xy-coordinates-of-objects-in-test_sender_rosbag","text":"Export the necessary topics of the Rosbag to a CSV file","title":"Plot the x,y coordinates of objects in test_sender_rosbag"}]}